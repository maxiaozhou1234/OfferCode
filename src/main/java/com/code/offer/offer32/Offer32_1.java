package com.code.offer.offer32;

public class Offer32_1 {

    //从1到n的整数中1出现的个数
    //如 输入12，1-12中1出现1,10,11,12 共5个1

    /*《编程之美》上这样说:

    设N = abcde ,其中abcde分别为十进制中各位上的数字。
    如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。
    如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，...，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。注意：高位数字不包括当前位
    如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，....，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共14个，等于低位数字（13）+1。 注意：低位数字不包括当前数字
    如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，...，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）
    */

    /*
        高位后的数字分别为1的总数 (len-1)*10^(len-2)

        如 x1234 高位后为 1234 >> 1235-x1234 中1出现的次数
        排列为： 1,_,_,_ 10^3
                _,1,_,_ 10^3
                _,_,1,_ 10^3
                _,_,_,1 10^3
                共 4*(10^3)
        这里可能会有疑问重复的问题，如果限定其中一位为1，那么全排列总数
            sum=C(10)(1)*C(10)(1)*C(10)(1)+C(9)(1)*C(10)(1)*C(10)(1)+C(9)(1)*C(9)(1)*C(10)(1)+C(9)(1)*C(9)(1)*C(9)(1)

        如果用 sum=C(10)(1)*C(10)(1)*C(10)(1)*C(10)(1) 对全排列有重复数字问题，因为当空格为1时，1_00 和 _100 是同一个数

        但是对于1的统计来说，1_00 和 _100 统计分别在千位和百位，故不重复
        eg:
            以剩余两位数中求1总数举例，len=3,"sum = (len-1)*10^(len-2)" -->> sum=2*10=20
            十位为1时有 1[0-9] 十位中1个数为10个，如果枚举实际是11个1其中“11”的个位1没有计入
            个位为1时有 [0-1]1 个位中1个数为10个，同样“11”的十位也没有算进来（注：十位0是允许的，因为前面还有一个数字）
            所以“11”出现了两次，一次计数十位，一次计数个位
    */
    public static void main(String[] args) {
        Offer32_1 test = new Offer32_1();

        test.input(12);
        test.input(23);
        test.input(21345);
    }

    public void input(int n) {
        System.out.println("input >> " + n);
        long time = System.currentTimeMillis();
        int count = countDigitOne(n);
        System.out.println(" |-- out >> count=" + count);
        System.out.println(" |-- time consuming: " + (System.currentTimeMillis() - time) + "ms");

    }

    private int countDigitOne(int n) {
        if (n < 1) return 0;

        int len = getLenOfNumber(n);
        if (len == 1) {//1-9
            return 1;
        }

        int pow = (int) Math.pow(10, len - 1);
        int first = n / pow;
        //计算高位为1的次数
        //如果first==1，那么高位出现1的次数等于高位后的数字+1 >> 1abcd -> count = abcd+1
        //如果first!=1(即>1，不用考虑0情况，高位为0abc不会进来，直接变输入abc，m0abc -> abc ，不存在0abc)
        //那么10..00 - 199..99 一定会出现，次数为 10^(len-1)

        //接下来计算高位后的数字分别为1的总数 (len-1)*10^(len-2)
        //如 x1234 高位后为 1234 >> 1235-x1234 中1出现的次数
        // 1,_,_,_ 10^3 | _,1,_,_  10^3 | _,_,1,_ 10^3 | _,_,_,1 10^3 共 4*(10^3)
        //这里可能会有疑问重复的问题，如果限定其中一位为1，那么全排列总数
        // sum=C(10)(1)*C(10)(1)*C(10)(1)+C(9)(1)*C(10)(1)*C(10)(1)+C(9)(1)*C(9)(1)*C(10)(1)+C(9)(1)*C(9)(1)*C(9)(1)
        //如果用 (C(10)(1))^4 对全排列有重复数字问题，因为当空格为1时，1_00 和 _100 是同一个数，但是对于1的统计来说，1_00 和 _100 统计分别在千位和百位，故不重复
        //假设第一位是1，那么a = 1_00，假设第二位是1的 b = _100，当空白为1时，a=b=1100，是否重复？
        //从排列上看，是重复了，但从1计数上说没有重复，当第一位是1，a=1100，我们只计数增加了第一位1，第二位1我们没有加入总数，所以是没有重复
        //以剩余两位数中求1总数举例，sum=2*10=20
        //十位为1时有 1[0-9] 十位中1个数为10个，如果枚举实际是11个1其中“11”的个位1没有计入
        //个位为1时有 [0-1]1 个位中1个数为10个，同样“11”的十位也没有算进来（注：十位0是允许的，因为前面还有一个数字）
        int firstHighCount = first == 1 ? n % pow + 1 : pow;// 获取n的最高位为1时有多少个数字
        int otherCount = first * (len - 1) * pow / 10;// 在介于n % tmp到n之间的数字中，除了最高位为1，其余各个数字分别为1 的总数和
        return firstHighCount + otherCount + countDigitOne(n % pow);
    }

    private int getLenOfNumber(int n) {
        int len = 0;
        while (n != 0) {
            len++;
            n = n / 10;
        }
        return len;
    }

}
